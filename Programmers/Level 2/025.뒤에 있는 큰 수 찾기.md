## 오늘의 학습
문제 링크 - [프로그래머스: 뒤에 있는 큰 수 찾기](https://school.programmers.co.kr/learn/courses/30/lessons/154539)
문제는 `구현`이었다.

<br />

## 오늘의 회고
#### 어떤 문제가 있었고, 나는 어떤 시도를 했는지
자연수 숫자들만 담긴 숫자 배열이 주어진다.

배열 의 각 원소들에 대해 자신보다 뒤에 있는 숫자 중에서 자신보다 크면서 가장 가까이 있는 수를 뒷 큰수라고 한다.

모든 원소에 대한 뒷 큰수들을 차례로 담은 배열을 return 한다.

뒷 큰수가 존재하지 않는 원소는 -1을 담는다.

<br />

#### 어떻게 해결했는지
주어진 배열의 크기가 1,000,000 이기때문에, 주어진 문제에 따라 2중 배열로 풀면 시간초과가 날 것이다.

이 문제의 핵심은 stack을 이용하여 불필요한 연산을 줄이는 것이다.

<br/>

스택에는 아직 다음 큰 수를 찾지 못한 숫자들의 위치를 저장한다.

새로운 숫자를 만날 때마다, 이 숫자가 스택에 저장된 위치의 숫자들보다 큰지 확인한다. 

만약 크다면, 스택에 있는 해당 위치의 '뒷 큰수'가 바로 이 새로운 숫자가 된다.

<br/>

예를 들어, [3, 5, 2, 7]이라는 배열이 있다면, 처음에는 3의 인덱스인 0을 스택에 넣다. (stack = [0])

그 다음 5를 만나면 stack의 제일 마지막 요소와 비교한다. 

0번째 인덱스의 값이 3과 5를 비교했을 때, 5가 더 크므로 0번째 인덱스의 '뒷 큰수'는 5이다. 

그래서 스택에서 뒤 큰수를 찾은 0번째 인덱스를 빼주고, 5의 인덱스인 1을 넣어준다.  (stack = [1])

그 다음으로 인덱스가 1인 요소의 값(5)보다 2가 작으므로 스택에 2의 인덱스인 2를 넣어준다. (stack = [1, 2])

마지막으로 7과 stack에 있는 요소를 비교한다. 

스택의 마지막 요소의 값(2)보다 7이 더 크므로 2의 뒷큰수는 7이고, 뒷큰수를 찾았으므로 stack에서 빼준다. (stack = [1])

마찬가지로 스택의 마지막 요소의 값(5)보다 7이 더 크므로, 5의 뒷큰수는 7이고 뒷큰수를 찾았으므로 stack에서 빼준다. (stack = [])

7은 마지막 숫자이므로 7의 다음 큰 수는 존재하지 않아 -1이 된다.

<br/>

이렇게 stack에 뒷큰수를 찾지못한 요소들의 index와 현재 인덱스의 값을 비교하게 하여 불필요한 연산을 줄였다.
